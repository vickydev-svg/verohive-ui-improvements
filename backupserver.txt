const express = require('express');
const app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);
({
    path: '/io/webrtc'
  })
var kurento = require('kurento-client');
var minimist = require('minimist');
const imageUploadRoute = require('./routes/upload')
const cors = require("cors")
const fileUpload = require('express-fileupload')
const session = require('express-session')
const passport = require('./passport')
const bodyParser = require('body-parser');
const { use } = require('passport');
const { prototype } = require('aws-sdk/clients/applicationautoscaling');


// variables
var kurentoClient = null;
var iceCandidateQueues = {};

// constants
var argv = minimist(process.argv.slice(2), {
    default: {
        as_uri: 'ws://localhost:65000/',
        ws_uri: 'ws://85.93.89.126:32768/kurento'
       
    }
});

// express routing
app.use(express.static(__dirname + '/build'))

app.set("view engine", "hbs")
app.use(cors())
app.use(fileUpload())
app.use(express.json())
app.use(express.urlencoded({extended: true}))
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
app.use(session({
    secret: 'somesecretstring'
}))
app.use(passport.initialize())
app.use(passport.session())
const port = 65000

const rooms = {}
const messages = {}
const file = {}
// app.get('/', (req, res) => res.send('Hello World!!!!!'))
const chats={

}
var users=[]

//https://expressjs.com/en/guide/writing-middleware.html
app.use(express.static(__dirname + '/build'))

app.use('/public', require('./routes/public'))
// app.use('/private', require('./routes/private'))
app.use('/nodemailer', require('./routes/nodemailer'))
app.use('/follow', require('./routes/follow'))

app.use('/api/v1/upload', imageUploadRoute)

app.use('/', require('./routes/root'))

app.get('/:room', (req, res, next) => {
  res.sendFile(__dirname + '/build/index.html')

})

app.post('/:room', (req, res, next) => {
  console.log(req.body)
  res.status(200).json({data: req.body})
})


// signaling
io.on('connection', function (socket) {
    console.log('a user connected');

   

   


    const peers = io.of('/webrtcPeer')

    // keep a reference of all socket connections
    // let connectedPeers = new Map()
    
    peers.on('connection', socket => {
    
      const room = socket.handshake.query.room
    
      rooms[room] = rooms[room] && rooms[room].set(socket.id, socket) || (new Map()).set(socket.id, socket)
      messages[room] = messages[room] || []
      file[room] = file[room] || []
      // chats[room]=chats[room]||[]
      // connectedPeers.set(socket.id, socket)
    
      console.log(socket.id, room)
      socket.emit('connection-success', {
        success: socket.id,
        peerCount: rooms[room].size,
        messages: messages[room],
        file:file[room],
        // chats:chats[room]
      })
    
      // const broadcast = () => socket.broadcast.emit('joined-peers', {
      //   peerCount: connectedPeers.size,
      // })
      const broadcast = () => {
        const _connectedPeers = rooms[room]
    
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          // if (socketID !== socket.id) {
            _socket.emit('joined-peers', {
              peerCount: rooms[room].size, //connectedPeers.size,
            })
          // }
        }
      }
      broadcast()
    
      // const disconnectedPeer = (socketID) => socket.broadcast.emit('peer-disconnected', {
      //   peerCount: connectedPeers.size,
      //   socketID: socketID
      // })
      const disconnectedPeer = (socketID) => {
        users = []
        const _connectedPeers = rooms[room]
        for (const [_socketID, _socket] of _connectedPeers.entries()) {
            _socket.emit('peer-disconnected', {
              peerCount: rooms[room].size,
              socketID
            })
        }
      }
    
      socket.on('new-message-to-user', (data) => {
        console.log('new-message-to-user',data.payload)
        users.push(data.payload)
        console.log("djdj",users)
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
        const _connectedPeers = rooms[room]
    
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          // if (socketID !== socket.id) {
            _socket.emit('new-message-to-user', {
              data: data.payload, //connectedPeers.size,
            })
          // }
        }
        // chats[room] = [...chats[room], JSON.parse(data.payload)]
      })
      socket.on('all-connected-users', (data) => {
        console.log('all-connected-users',data.payload)
        users.push(data.payload)
        console.log("djdj",users)
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
        const _connectedPeers = rooms[room]
    
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          // if (socketID !== socket.id) {
            _socket.emit('all-connected-users', {
              data: data.payload, //connectedPeers.size,
            })
          // }
        }
        // chats[room] = [...chats[room], JSON.parse(data.payload)]
      })
      socket.on('new-message-to-specific-user', (data) => {
        console.log('new-message-to-specific-user',data)
        // users.push(data.payload)
        // console.log("djdj",users)
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
        const _connectedPeers = rooms[room]
       console.log("ss",_connectedPeers.rooms)
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          if (socketID==data.socketID.local) {
            _socket.emit('new-message-to-specific-user', {
              data:data.payload, //connectedPeers.size,
            })
          }
        }
        // chats[room] = [...chats[room], JSON.parse(data.payload)]
      })
      socket.on('disconnect-to-specific-user', (data) => {
        console.log('disconnect-to-specific-user',data)
        
        // users.push(data.payload)
        // console.log("djdj",users)
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
        const _connectedPeers = rooms[room]
    
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          if (socketID==data.socketID.local) {
            _socket.emit('disconnect-to-specific-user', {
              data:data.payload, //connectedPeers.size,
            })
          }
        }
        // chats[room] = [...chats[room], JSON.parse(data.payload)]
      })
      socket.on('mute-mic-to-specific-user', (data) => {
        console.log('mute-mic-to-specific-user',data)
        // users.push(data.payload)
        // console.log("djdj",users)
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
        const _connectedPeers = rooms[room]
        console.log("ss",_connectedPeers)
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          if (socketID==data.socketID.local) {
            _socket.emit('mute-mic-to-specific-user', {
              data:data.payload, //connectedPeers.size,
            })
          }
        }
        // chats[room] = [...chats[room], JSON.parse(data.payload)]
      })
      socket.on('new-message', (data) => {
        console.log('new-message', JSON.parse(data.payload))
    
        messages[room] = [...messages[room], JSON.parse(data.payload)]
      })
      socket.on('new-file', (data) => {
        console.log("Ddd",data)
        file[room] = [...file[room], JSON.parse(data.payload)]
        // messages[room] = [...messages[room], JSON.parse(data.payload)]
      })
    
      socket.on('disconnect', () => {
        console.log('disconnected')
        // connectedPeers.delete(socket.id)
        rooms[room].delete(socket.id)
        users=[]
        
        messages[room] = rooms[room].size === 0 ? null : messages[room]
        disconnectedPeer(socket.id)
      })
 
      socket.on('socket-to-disconnect', (socketIDToDisconnect) => {
        users=[]
        console.log('disconnected')
        // connectedPeers.delete(socket.id)
        rooms[room].delete(socketIDToDisconnect)
        messages[room] = rooms[room].size === 0 ? null : messages[room]
        disconnectedPeer(socketIDToDisconnect)
      })
    
      socket.on('onlinePeers', (data) => {
        const _connectedPeers = rooms[room]
        for (const [socketID, _socket] of _connectedPeers.entries()) {
          // don't send to self
          if (socketID !== data.socketID.local) {
            console.log('online-peer', data.socketID, socketID)
            socket.emit('online-peer', socketID)
          }
        }
      })
    
      // socket.on('offer', data => {
      //   console.log(data)
      //   const _connectedPeers = rooms[room]
      //   for (const [socketID, socket] of _connectedPeers.entries()) {
      //     // don't send to self
      //     if (socketID === data.socketID.remote) {
      //       // console.log('Offer', socketID, data.socketID, data.payload.type)
      //       socket.emit('offer', {
      //           sdp: data.payload,
      //           socketID: data.socketID.local
      //         }
      //       )
      //     }
      //   }
      // })
    
      // socket.on('answer', (data) => {
      //   console.log(data)
      //   const _connectedPeers = rooms[room]
      //   for (const [socketID, socket] of _connectedPeers.entries()) {
      //     if (socketID === data.socketID.remote) {
      //       console.log('Answer', socketID, data.socketID, data.payload.type)
      //       socket.emit('answer', {
      //           sdp: data.payload,
      //           socketID: data.socketID.local
      //         }
      //       )
      //     }
      //   }
      // })

      socket.on('file-send-room', function (file) {
        console.log(file);
        socket.to(channel).emit('file-out-room', file);
    });
    socket.on('file-send-room-result', function (file) {
        console.log(file);
        socket.to(channel).emit('file-out-room-result', file);
    });
      // socket.on('offerOrAnswer', (data) => {
      //   // send to the other peer(s) if any
      //   for (const [socketID, socket] of connectedPeers.entries()) {
      //     // don't send to self
      //     if (socketID !== data.socketID) {
      //       console.log(socketID, data.payload.type)
      //       socket.emit('offerOrAnswer', data.payload)
      //     }
      //   }
      // })
    
      // socket.on('candidate', (data) => {
      //   console.log(data)
      //   const _connectedPeers = rooms[room]
      //   // send candidate to the other peer(s) if any
      //   for (const [socketID, socket] of _connectedPeers.entries()) {
      //     if (socketID === data.socketID.remote) {
      //       socket.emit('candidate', {
      //         candidate: data.payload,
      //         socketID: data.socketID.local
      //       })
      //     }
      //   }
      // })
    
    })


    socket.on('message', function (message) {
      console.log('Message received: ', message.event);

      switch (message.event) {
          case 'joinRoom':
              joinRoom(socket, message.userName, message.roomName, err => {
                  if (err) {
                      console.log(err);
                  }
              });
              break;

          case 'receiveVideoFrom':
              receiveVideoFrom(socket, message.userid, message.roomName, message.sdpOffer, err => {
                  if (err) {
                      console.log(err);
                  }
              });
              break;

          case 'candidate':
              addIceCandidate(socket, message.userid, message.roomName, message.candidate, err => {
                  if (err) {
                      console.log(err);
                  }
              });
              break;
      }

  });


});

// signaling functions
function joinRoom(socket, username, roomname, callback) {
    getRoom(socket, roomname, (err, myRoom) => {
        if (err) {
            return callback(err);
        }

        myRoom.pipeline.create('WebRtcEndpoint', (err, outgoingMedia) => {
            if (err) {
                return callback(err);
            }

            var user = {
                id: socket.id,
                name: username,
                outgoingMedia: outgoingMedia,
                incomingMedia: {}
            }

            let iceCandidateQueue = iceCandidateQueues[user.id];
            if (iceCandidateQueue) {
                while (iceCandidateQueue.length) {
                    let ice = iceCandidateQueue.shift();
                    console.error(`user: ${user.name} collect candidate for outgoing media`);
                    user.outgoingMedia.addIceCandidate(ice.candidate);
                }
            }

            user.outgoingMedia.on('OnIceCandidate', event => {
                let candidate = kurento.register.complexTypes.IceCandidate(event.candidate);
                socket.emit('message', {
                    event: 'candidate',
                    userid: user.id,
                    candidate: candidate
                });
            });

            socket.to(roomname).emit('message', {
                event: 'newParticipantArrived', 
                userid: user.id,
                username: user.name
            });

            let existingUsers = [];
            for (let i in myRoom.participants) {
                if (myRoom.participants[i].id != user.id) {
                    existingUsers.push({
                        id: myRoom.participants[i].id,
                        name: myRoom.participants[i].name
                    });
                }
            }
            socket.emit('message', {
                event: 'existingParticipants', 
                existingUsers: existingUsers,
                userid: user.id
            });

            myRoom.participants[user.id] = user;
        });
    });
}



function receiveVideoFrom(socket, userid, roomname, sdpOffer, callback) {
    getEndpointForUser(socket, roomname, userid, (err, endpoint) => {
        if (err) {
            return callback(err);
        }

        endpoint.processOffer(sdpOffer, (err, sdpAnswer) => {
            if (err) {
                return callback(err);
            }

            socket.emit('message', {
                event: 'receiveVideoAnswer',
                senderid: userid,
                sdpAnswer: sdpAnswer
            });

            endpoint.gatherCandidates(err => {
                if (err) {
                    return callback(err);
                }
            });
        });
    })
}

function addIceCandidate(socket, senderid, roomname, iceCandidate, callback) {
    let user = io.sockets.adapter.rooms[roomname].participants[socket.id];
    if (user != null) {
        let candidate = kurento.register.complexTypes.IceCandidate(iceCandidate);
        if (senderid == user.id) {
            if (user.outgoingMedia) {
                user.outgoingMedia.addIceCandidate(candidate);
            } else {
                iceCandidateQueues[user.id].push({candidate: candidate});
            }
        } else {
            if (user.incomingMedia[senderid]) {
                user.incomingMedia[senderid].addIceCandidate(candidate);
            } else {
                if (!iceCandidateQueues[senderid]) {
                    iceCandidateQueues[senderid] = [];
                }
                iceCandidateQueues[senderid].push({candidate: candidate});
            }   
        }
        callback(null);
    } else {
        callback(new Error("addIceCandidate failed"));
    }
}

// useful functions
function getRoom(socket, roomname, callback) {
    var myRoom = io.sockets.adapter.rooms[roomname] || { length: 0 };
    var numClients = myRoom.length;

    console.log(roomname, ' has ', numClients, ' clients');

    if (numClients == 0) {
        socket.join(roomname, () => {
            myRoom = io.sockets.adapter.rooms[roomname];
            getKurentoClient((error, kurento) => {
                kurento.create('MediaPipeline', (err, pipeline) => {
                    if (error) {
                        return callback(err);
                    }

                    myRoom.pipeline = pipeline;
                    myRoom.participants = {};
                    callback(null, myRoom);
                });
            });
        });
    } else {
        socket.join(roomname);
        callback(null, myRoom);
    }
}

function getEndpointForUser(socket, roomname, senderid, callback) {
    var myRoom = io.sockets.adapter.rooms[roomname];
    var asker = myRoom.participants[socket.id];
    var sender = myRoom.participants[senderid];

    if (asker.id === sender.id) {
        return callback(null, asker.outgoingMedia);
    }

    if (asker.incomingMedia[sender.id]) {
        sender.outgoingMedia.connect(asker.incomingMedia[sender.id], err => {
            if (err) {
                return callback(err);
            }
            callback(null, asker.incomingMedia[sender.id]);
        });
    } else {
        myRoom.pipeline.create('WebRtcEndpoint', (err, incoming) => {
            if (err) {
                return callback(err);
            }

            asker.incomingMedia[sender.id] = incoming;

            let iceCandidateQueue = iceCandidateQueues[sender.id];
            if (iceCandidateQueue) {
                while (iceCandidateQueue.length) {
                    let ice = iceCandidateQueue.shift();
                    console.error(`user: ${sender.name} collect candidate for outgoing media`);
                    incoming.addIceCandidate(ice.candidate);
                }
            }

            incoming.on('OnIceCandidate', event => {
                let candidate = kurento.register.complexTypes.IceCandidate(event.candidate);
                socket.emit('message', {
                    event: 'candidate',
                    userid: sender.id,
                    candidate: candidate
                });
            });

            sender.outgoingMedia.connect(incoming, err => {
                if (err) {
                    return callback(err);
                }
                callback(null, incoming);
            });
        });
    }
}


function getKurentoClient(callback) {
    if (kurentoClient !== null) {
        return callback(null, kurentoClient);
    }

    kurento(argv.ws_uri, function (error, _kurentoClient) {
        if (error) {
            console.log("Could not find media server at address " + argv.ws_uri);
            return callback("Could not find media server at address" + argv.ws_uri
                + ". Exiting with error " + error);
        }

        kurentoClient = _kurentoClient;
        callback(null, kurentoClient);
    });
}

// listen
// http.listen(port, function () {
//     console.log('Example app listening on port 3000!');
// });

const server = app.listen(port, () => console.log(`Example app listening on port ${port}!`))

io.listen(server)